// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pelldvs/avsi/types.proto

package types

import (
	context "context"
	fmt "fmt"
	crypto "github.com/0xPellNetwork/pelldvs/proto/pelldvs/crypto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ----------------------------------------
// Request types
type Request struct {
	// Types that are valid to be assigned to Value:
	//	*Request_Flush
	//	*Request_Echo
	//	*Request_Info
	//	*Request_Query
	//	*Request_ProcessDvsRequest
	//	*Request_ProcessDvsResponse
	Value isRequest_Value `protobuf_oneof:"value"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

type isRequest_Value interface {
	isRequest_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Request_Flush struct {
	Flush *RequestFlush `protobuf:"bytes,1,opt,name=flush,proto3,oneof" json:"flush,omitempty"`
}
type Request_Echo struct {
	Echo *RequestEcho `protobuf:"bytes,2,opt,name=echo,proto3,oneof" json:"echo,omitempty"`
}
type Request_Info struct {
	Info *RequestInfo `protobuf:"bytes,3,opt,name=info,proto3,oneof" json:"info,omitempty"`
}
type Request_Query struct {
	Query *RequestQuery `protobuf:"bytes,4,opt,name=query,proto3,oneof" json:"query,omitempty"`
}
type Request_ProcessDvsRequest struct {
	ProcessDvsRequest *RequestProcessDVSRequest `protobuf:"bytes,5,opt,name=process_dvs_request,json=processDvsRequest,proto3,oneof" json:"process_dvs_request,omitempty"`
}
type Request_ProcessDvsResponse struct {
	ProcessDvsResponse *RequestProcessDVSResponse `protobuf:"bytes,6,opt,name=process_dvs_response,json=processDvsResponse,proto3,oneof" json:"process_dvs_response,omitempty"`
}

func (*Request_Flush) isRequest_Value()              {}
func (*Request_Echo) isRequest_Value()               {}
func (*Request_Info) isRequest_Value()               {}
func (*Request_Query) isRequest_Value()              {}
func (*Request_ProcessDvsRequest) isRequest_Value()  {}
func (*Request_ProcessDvsResponse) isRequest_Value() {}

func (m *Request) GetValue() isRequest_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Request) GetFlush() *RequestFlush {
	if x, ok := m.GetValue().(*Request_Flush); ok {
		return x.Flush
	}
	return nil
}

func (m *Request) GetEcho() *RequestEcho {
	if x, ok := m.GetValue().(*Request_Echo); ok {
		return x.Echo
	}
	return nil
}

func (m *Request) GetInfo() *RequestInfo {
	if x, ok := m.GetValue().(*Request_Info); ok {
		return x.Info
	}
	return nil
}

func (m *Request) GetQuery() *RequestQuery {
	if x, ok := m.GetValue().(*Request_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Request) GetProcessDvsRequest() *RequestProcessDVSRequest {
	if x, ok := m.GetValue().(*Request_ProcessDvsRequest); ok {
		return x.ProcessDvsRequest
	}
	return nil
}

func (m *Request) GetProcessDvsResponse() *RequestProcessDVSResponse {
	if x, ok := m.GetValue().(*Request_ProcessDvsResponse); ok {
		return x.ProcessDvsResponse
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Request) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Request_Flush)(nil),
		(*Request_Echo)(nil),
		(*Request_Info)(nil),
		(*Request_Query)(nil),
		(*Request_ProcessDvsRequest)(nil),
		(*Request_ProcessDvsResponse)(nil),
	}
}

// Response types
type Response struct {
	// Types that are valid to be assigned to Value:
	//	*Response_Exception
	//	*Response_Flush
	//	*Response_Echo
	//	*Response_Info
	//	*Response_Query
	//	*Response_ProcessDvsRequest
	//	*Response_ProcessDvsResponse
	Value isResponse_Value `protobuf_oneof:"value"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{1}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

type isResponse_Value interface {
	isResponse_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Response_Exception struct {
	Exception *ResponseException `protobuf:"bytes,1,opt,name=exception,proto3,oneof" json:"exception,omitempty"`
}
type Response_Flush struct {
	Flush *ResponseFlush `protobuf:"bytes,2,opt,name=flush,proto3,oneof" json:"flush,omitempty"`
}
type Response_Echo struct {
	Echo *ResponseEcho `protobuf:"bytes,3,opt,name=echo,proto3,oneof" json:"echo,omitempty"`
}
type Response_Info struct {
	Info *ResponseInfo `protobuf:"bytes,4,opt,name=info,proto3,oneof" json:"info,omitempty"`
}
type Response_Query struct {
	Query *ResponseQuery `protobuf:"bytes,5,opt,name=query,proto3,oneof" json:"query,omitempty"`
}
type Response_ProcessDvsRequest struct {
	ProcessDvsRequest *ResponseProcessDVSRequest `protobuf:"bytes,6,opt,name=process_dvs_request,json=processDvsRequest,proto3,oneof" json:"process_dvs_request,omitempty"`
}
type Response_ProcessDvsResponse struct {
	ProcessDvsResponse *ResponseProcessDVSResponse `protobuf:"bytes,7,opt,name=process_dvs_response,json=processDvsResponse,proto3,oneof" json:"process_dvs_response,omitempty"`
}

func (*Response_Exception) isResponse_Value()          {}
func (*Response_Flush) isResponse_Value()              {}
func (*Response_Echo) isResponse_Value()               {}
func (*Response_Info) isResponse_Value()               {}
func (*Response_Query) isResponse_Value()              {}
func (*Response_ProcessDvsRequest) isResponse_Value()  {}
func (*Response_ProcessDvsResponse) isResponse_Value() {}

func (m *Response) GetValue() isResponse_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Response) GetException() *ResponseException {
	if x, ok := m.GetValue().(*Response_Exception); ok {
		return x.Exception
	}
	return nil
}

func (m *Response) GetFlush() *ResponseFlush {
	if x, ok := m.GetValue().(*Response_Flush); ok {
		return x.Flush
	}
	return nil
}

func (m *Response) GetEcho() *ResponseEcho {
	if x, ok := m.GetValue().(*Response_Echo); ok {
		return x.Echo
	}
	return nil
}

func (m *Response) GetInfo() *ResponseInfo {
	if x, ok := m.GetValue().(*Response_Info); ok {
		return x.Info
	}
	return nil
}

func (m *Response) GetQuery() *ResponseQuery {
	if x, ok := m.GetValue().(*Response_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Response) GetProcessDvsRequest() *ResponseProcessDVSRequest {
	if x, ok := m.GetValue().(*Response_ProcessDvsRequest); ok {
		return x.ProcessDvsRequest
	}
	return nil
}

func (m *Response) GetProcessDvsResponse() *ResponseProcessDVSResponse {
	if x, ok := m.GetValue().(*Response_ProcessDvsResponse); ok {
		return x.ProcessDvsResponse
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Response) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Response_Exception)(nil),
		(*Response_Flush)(nil),
		(*Response_Echo)(nil),
		(*Response_Info)(nil),
		(*Response_Query)(nil),
		(*Response_ProcessDvsRequest)(nil),
		(*Response_ProcessDvsResponse)(nil),
	}
}

// -----------------------------DVS----------------------------------
type DVSRequest struct {
	Data                      []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Height                    int64    `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	ChainId                   int64    `protobuf:"varint,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	GroupNumbers              []uint32 `protobuf:"varint,4,rep,packed,name=group_numbers,json=groupNumbers,proto3" json:"group_numbers,omitempty"`
	GroupThresholdPercentages []uint32 `protobuf:"varint,5,rep,packed,name=group_threshold_percentages,json=groupThresholdPercentages,proto3" json:"group_threshold_percentages,omitempty"`
}

func (m *DVSRequest) Reset()         { *m = DVSRequest{} }
func (m *DVSRequest) String() string { return proto.CompactTextString(m) }
func (*DVSRequest) ProtoMessage()    {}
func (*DVSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{2}
}
func (m *DVSRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DVSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DVSRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DVSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DVSRequest.Merge(m, src)
}
func (m *DVSRequest) XXX_Size() int {
	return m.Size()
}
func (m *DVSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DVSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DVSRequest proto.InternalMessageInfo

func (m *DVSRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DVSRequest) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *DVSRequest) GetChainId() int64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *DVSRequest) GetGroupNumbers() []uint32 {
	if m != nil {
		return m.GroupNumbers
	}
	return nil
}

func (m *DVSRequest) GetGroupThresholdPercentages() []uint32 {
	if m != nil {
		return m.GroupThresholdPercentages
	}
	return nil
}

type OperatorPubkeys struct {
	G1Pubkey []byte `protobuf:"bytes,1,opt,name=g1_pubkey,json=g1Pubkey,proto3" json:"g1_pubkey,omitempty"`
	G2Pubkey []byte `protobuf:"bytes,2,opt,name=g2_pubkey,json=g2Pubkey,proto3" json:"g2_pubkey,omitempty"`
}

func (m *OperatorPubkeys) Reset()         { *m = OperatorPubkeys{} }
func (m *OperatorPubkeys) String() string { return proto.CompactTextString(m) }
func (*OperatorPubkeys) ProtoMessage()    {}
func (*OperatorPubkeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{3}
}
func (m *OperatorPubkeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorPubkeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorPubkeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorPubkeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorPubkeys.Merge(m, src)
}
func (m *OperatorPubkeys) XXX_Size() int {
	return m.Size()
}
func (m *OperatorPubkeys) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorPubkeys.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorPubkeys proto.InternalMessageInfo

func (m *OperatorPubkeys) GetG1Pubkey() []byte {
	if m != nil {
		return m.G1Pubkey
	}
	return nil
}

func (m *OperatorPubkeys) GetG2Pubkey() []byte {
	if m != nil {
		return m.G2Pubkey
	}
	return nil
}

type Operator struct {
	Id      []byte           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Address []byte           `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	MetaUri string           `protobuf:"bytes,3,opt,name=meta_uri,json=metaUri,proto3" json:"meta_uri,omitempty"`
	Socket  string           `protobuf:"bytes,4,opt,name=socket,proto3" json:"socket,omitempty"`
	Stake   int64            `protobuf:"varint,5,opt,name=stake,proto3" json:"stake,omitempty"`
	Pubkeys *OperatorPubkeys `protobuf:"bytes,6,opt,name=pubkeys,proto3" json:"pubkeys,omitempty"`
}

func (m *Operator) Reset()         { *m = Operator{} }
func (m *Operator) String() string { return proto.CompactTextString(m) }
func (*Operator) ProtoMessage()    {}
func (*Operator) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{4}
}
func (m *Operator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Operator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Operator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Operator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operator.Merge(m, src)
}
func (m *Operator) XXX_Size() int {
	return m.Size()
}
func (m *Operator) XXX_DiscardUnknown() {
	xxx_messageInfo_Operator.DiscardUnknown(m)
}

var xxx_messageInfo_Operator proto.InternalMessageInfo

func (m *Operator) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Operator) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Operator) GetMetaUri() string {
	if m != nil {
		return m.MetaUri
	}
	return ""
}

func (m *Operator) GetSocket() string {
	if m != nil {
		return m.Socket
	}
	return ""
}

func (m *Operator) GetStake() int64 {
	if m != nil {
		return m.Stake
	}
	return 0
}

func (m *Operator) GetPubkeys() *OperatorPubkeys {
	if m != nil {
		return m.Pubkeys
	}
	return nil
}

type RequestProcessDVSRequest struct {
	Request  *DVSRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	Operator []*Operator `protobuf:"bytes,2,rep,name=operator,proto3" json:"operator,omitempty"`
}

func (m *RequestProcessDVSRequest) Reset()         { *m = RequestProcessDVSRequest{} }
func (m *RequestProcessDVSRequest) String() string { return proto.CompactTextString(m) }
func (*RequestProcessDVSRequest) ProtoMessage()    {}
func (*RequestProcessDVSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{5}
}
func (m *RequestProcessDVSRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestProcessDVSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestProcessDVSRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestProcessDVSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestProcessDVSRequest.Merge(m, src)
}
func (m *RequestProcessDVSRequest) XXX_Size() int {
	return m.Size()
}
func (m *RequestProcessDVSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestProcessDVSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RequestProcessDVSRequest proto.InternalMessageInfo

func (m *RequestProcessDVSRequest) GetRequest() *DVSRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *RequestProcessDVSRequest) GetOperator() []*Operator {
	if m != nil {
		return m.Operator
	}
	return nil
}

type RequestProcessDVSResponse struct {
	DvsRequest  *DVSRequest  `protobuf:"bytes,1,opt,name=dvs_request,json=dvsRequest,proto3" json:"dvs_request,omitempty"`
	DvsResponse *DVSResponse `protobuf:"bytes,2,opt,name=dvs_response,json=dvsResponse,proto3" json:"dvs_response,omitempty"`
}

func (m *RequestProcessDVSResponse) Reset()         { *m = RequestProcessDVSResponse{} }
func (m *RequestProcessDVSResponse) String() string { return proto.CompactTextString(m) }
func (*RequestProcessDVSResponse) ProtoMessage()    {}
func (*RequestProcessDVSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{6}
}
func (m *RequestProcessDVSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestProcessDVSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestProcessDVSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestProcessDVSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestProcessDVSResponse.Merge(m, src)
}
func (m *RequestProcessDVSResponse) XXX_Size() int {
	return m.Size()
}
func (m *RequestProcessDVSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestProcessDVSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RequestProcessDVSResponse proto.InternalMessageInfo

func (m *RequestProcessDVSResponse) GetDvsRequest() *DVSRequest {
	if m != nil {
		return m.DvsRequest
	}
	return nil
}

func (m *RequestProcessDVSResponse) GetDvsResponse() *DVSResponse {
	if m != nil {
		return m.DvsResponse
	}
	return nil
}

type ResponseProcessDVSRequest struct {
	Code           uint32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data           []byte  `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Log            string  `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
	Info           string  `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	Events         []Event `protobuf:"bytes,5,rep,name=events,proto3" json:"events,omitempty"`
	Codespace      string  `protobuf:"bytes,6,opt,name=codespace,proto3" json:"codespace,omitempty"`
	Response       []byte  `protobuf:"bytes,7,opt,name=response,proto3" json:"response,omitempty"`
	ResponseDigest []byte  `protobuf:"bytes,8,opt,name=response_digest,json=responseDigest,proto3" json:"response_digest,omitempty"`
}

func (m *ResponseProcessDVSRequest) Reset()         { *m = ResponseProcessDVSRequest{} }
func (m *ResponseProcessDVSRequest) String() string { return proto.CompactTextString(m) }
func (*ResponseProcessDVSRequest) ProtoMessage()    {}
func (*ResponseProcessDVSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{7}
}
func (m *ResponseProcessDVSRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseProcessDVSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseProcessDVSRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseProcessDVSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseProcessDVSRequest.Merge(m, src)
}
func (m *ResponseProcessDVSRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResponseProcessDVSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseProcessDVSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseProcessDVSRequest proto.InternalMessageInfo

func (m *ResponseProcessDVSRequest) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ResponseProcessDVSRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ResponseProcessDVSRequest) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

func (m *ResponseProcessDVSRequest) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *ResponseProcessDVSRequest) GetEvents() []Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *ResponseProcessDVSRequest) GetCodespace() string {
	if m != nil {
		return m.Codespace
	}
	return ""
}

func (m *ResponseProcessDVSRequest) GetResponse() []byte {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *ResponseProcessDVSRequest) GetResponseDigest() []byte {
	if m != nil {
		return m.ResponseDigest
	}
	return nil
}

type ResponseProcessDVSResponse struct {
	Code      uint32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data      []byte  `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Log       string  `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
	Info      string  `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	Events    []Event `protobuf:"bytes,5,rep,name=events,proto3" json:"events,omitempty"`
	Codespace string  `protobuf:"bytes,6,opt,name=codespace,proto3" json:"codespace,omitempty"`
}

func (m *ResponseProcessDVSResponse) Reset()         { *m = ResponseProcessDVSResponse{} }
func (m *ResponseProcessDVSResponse) String() string { return proto.CompactTextString(m) }
func (*ResponseProcessDVSResponse) ProtoMessage()    {}
func (*ResponseProcessDVSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{8}
}
func (m *ResponseProcessDVSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseProcessDVSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseProcessDVSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseProcessDVSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseProcessDVSResponse.Merge(m, src)
}
func (m *ResponseProcessDVSResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResponseProcessDVSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseProcessDVSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseProcessDVSResponse proto.InternalMessageInfo

func (m *ResponseProcessDVSResponse) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ResponseProcessDVSResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ResponseProcessDVSResponse) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

func (m *ResponseProcessDVSResponse) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *ResponseProcessDVSResponse) GetEvents() []Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *ResponseProcessDVSResponse) GetCodespace() string {
	if m != nil {
		return m.Codespace
	}
	return ""
}

type Event struct {
	Type       string           `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Attributes []EventAttribute `protobuf:"bytes,2,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{9}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Event) GetAttributes() []EventAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type EventAttribute struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Index bool   `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *EventAttribute) Reset()         { *m = EventAttribute{} }
func (m *EventAttribute) String() string { return proto.CompactTextString(m) }
func (*EventAttribute) ProtoMessage()    {}
func (*EventAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{10}
}
func (m *EventAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAttribute.Merge(m, src)
}
func (m *EventAttribute) XXX_Size() int {
	return m.Size()
}
func (m *EventAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_EventAttribute proto.InternalMessageInfo

func (m *EventAttribute) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventAttribute) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *EventAttribute) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

// --------------------
// DVSResponse
type DVSResponse struct {
	Data                        []byte                  `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Error                       string                  `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Hash                        []byte                  `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	NonSignersPubkeysG1         [][]byte                `protobuf:"bytes,4,rep,name=non_signers_pubkeys_g1,json=nonSignersPubkeysG1,proto3" json:"non_signers_pubkeys_g1,omitempty"`
	GroupApksG1                 [][]byte                `protobuf:"bytes,5,rep,name=group_apks_g1,json=groupApksG1,proto3" json:"group_apks_g1,omitempty"`
	SignersApkG2                []byte                  `protobuf:"bytes,6,opt,name=signers_apk_g2,json=signersApkG2,proto3" json:"signers_apk_g2,omitempty"`
	SignersAggSigG1             []byte                  `protobuf:"bytes,7,opt,name=signers_agg_sig_g1,json=signersAggSigG1,proto3" json:"signers_agg_sig_g1,omitempty"`
	NonSignerGroupBitmapIndices []uint32                `protobuf:"varint,8,rep,packed,name=non_signer_group_bitmap_indices,json=nonSignerGroupBitmapIndices,proto3" json:"non_signer_group_bitmap_indices,omitempty"`
	GroupApkIndices             []uint32                `protobuf:"varint,9,rep,packed,name=group_apk_indices,json=groupApkIndices,proto3" json:"group_apk_indices,omitempty"`
	TotalStakeIndices           []uint32                `protobuf:"varint,10,rep,packed,name=total_stake_indices,json=totalStakeIndices,proto3" json:"total_stake_indices,omitempty"`
	NonSignerStakeIndices       []*NonSignerStakeIndice `protobuf:"bytes,11,rep,name=non_signer_stake_indices,json=nonSignerStakeIndices,proto3" json:"non_signer_stake_indices,omitempty"`
}

func (m *DVSResponse) Reset()         { *m = DVSResponse{} }
func (m *DVSResponse) String() string { return proto.CompactTextString(m) }
func (*DVSResponse) ProtoMessage()    {}
func (*DVSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{11}
}
func (m *DVSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DVSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DVSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DVSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DVSResponse.Merge(m, src)
}
func (m *DVSResponse) XXX_Size() int {
	return m.Size()
}
func (m *DVSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DVSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DVSResponse proto.InternalMessageInfo

func (m *DVSResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DVSResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *DVSResponse) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *DVSResponse) GetNonSignersPubkeysG1() [][]byte {
	if m != nil {
		return m.NonSignersPubkeysG1
	}
	return nil
}

func (m *DVSResponse) GetGroupApksG1() [][]byte {
	if m != nil {
		return m.GroupApksG1
	}
	return nil
}

func (m *DVSResponse) GetSignersApkG2() []byte {
	if m != nil {
		return m.SignersApkG2
	}
	return nil
}

func (m *DVSResponse) GetSignersAggSigG1() []byte {
	if m != nil {
		return m.SignersAggSigG1
	}
	return nil
}

func (m *DVSResponse) GetNonSignerGroupBitmapIndices() []uint32 {
	if m != nil {
		return m.NonSignerGroupBitmapIndices
	}
	return nil
}

func (m *DVSResponse) GetGroupApkIndices() []uint32 {
	if m != nil {
		return m.GroupApkIndices
	}
	return nil
}

func (m *DVSResponse) GetTotalStakeIndices() []uint32 {
	if m != nil {
		return m.TotalStakeIndices
	}
	return nil
}

func (m *DVSResponse) GetNonSignerStakeIndices() []*NonSignerStakeIndice {
	if m != nil {
		return m.NonSignerStakeIndices
	}
	return nil
}

type NonSignerStakeIndice struct {
	NonSignerStakeIndice []uint32 `protobuf:"varint,1,rep,packed,name=non_signer_stake_indice,json=nonSignerStakeIndice,proto3" json:"non_signer_stake_indice,omitempty"`
}

func (m *NonSignerStakeIndice) Reset()         { *m = NonSignerStakeIndice{} }
func (m *NonSignerStakeIndice) String() string { return proto.CompactTextString(m) }
func (*NonSignerStakeIndice) ProtoMessage()    {}
func (*NonSignerStakeIndice) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{12}
}
func (m *NonSignerStakeIndice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NonSignerStakeIndice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NonSignerStakeIndice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NonSignerStakeIndice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NonSignerStakeIndice.Merge(m, src)
}
func (m *NonSignerStakeIndice) XXX_Size() int {
	return m.Size()
}
func (m *NonSignerStakeIndice) XXX_DiscardUnknown() {
	xxx_messageInfo_NonSignerStakeIndice.DiscardUnknown(m)
}

var xxx_messageInfo_NonSignerStakeIndice proto.InternalMessageInfo

func (m *NonSignerStakeIndice) GetNonSignerStakeIndice() []uint32 {
	if m != nil {
		return m.NonSignerStakeIndice
	}
	return nil
}

// --------------------
// dvs request result idx
type DVSRequestResult struct {
	DvsRequest                 *DVSRequest                 `protobuf:"bytes,1,opt,name=dvs_request,json=dvsRequest,proto3" json:"dvs_request,omitempty"`
	ResponseProcessDvsRequest  *ResponseProcessDVSRequest  `protobuf:"bytes,2,opt,name=response_process_dvs_request,json=responseProcessDvsRequest,proto3" json:"response_process_dvs_request,omitempty"`
	DvsResponse                *DVSResponse                `protobuf:"bytes,3,opt,name=dvs_response,json=dvsResponse,proto3" json:"dvs_response,omitempty"`
	ResponseProcessDvsResponse *ResponseProcessDVSResponse `protobuf:"bytes,4,opt,name=response_process_dvs_response,json=responseProcessDvsResponse,proto3" json:"response_process_dvs_response,omitempty"`
}

func (m *DVSRequestResult) Reset()         { *m = DVSRequestResult{} }
func (m *DVSRequestResult) String() string { return proto.CompactTextString(m) }
func (*DVSRequestResult) ProtoMessage()    {}
func (*DVSRequestResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{13}
}
func (m *DVSRequestResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DVSRequestResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DVSRequestResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DVSRequestResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DVSRequestResult.Merge(m, src)
}
func (m *DVSRequestResult) XXX_Size() int {
	return m.Size()
}
func (m *DVSRequestResult) XXX_DiscardUnknown() {
	xxx_messageInfo_DVSRequestResult.DiscardUnknown(m)
}

var xxx_messageInfo_DVSRequestResult proto.InternalMessageInfo

func (m *DVSRequestResult) GetDvsRequest() *DVSRequest {
	if m != nil {
		return m.DvsRequest
	}
	return nil
}

func (m *DVSRequestResult) GetResponseProcessDvsRequest() *ResponseProcessDVSRequest {
	if m != nil {
		return m.ResponseProcessDvsRequest
	}
	return nil
}

func (m *DVSRequestResult) GetDvsResponse() *DVSResponse {
	if m != nil {
		return m.DvsResponse
	}
	return nil
}

func (m *DVSRequestResult) GetResponseProcessDvsResponse() *ResponseProcessDVSResponse {
	if m != nil {
		return m.ResponseProcessDvsResponse
	}
	return nil
}

// TODO: Adapt to our business logic
// -----------------------------reserver----------------------------------
type RequestFlush struct {
}

func (m *RequestFlush) Reset()         { *m = RequestFlush{} }
func (m *RequestFlush) String() string { return proto.CompactTextString(m) }
func (*RequestFlush) ProtoMessage()    {}
func (*RequestFlush) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{14}
}
func (m *RequestFlush) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestFlush) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestFlush.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestFlush) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestFlush.Merge(m, src)
}
func (m *RequestFlush) XXX_Size() int {
	return m.Size()
}
func (m *RequestFlush) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestFlush.DiscardUnknown(m)
}

var xxx_messageInfo_RequestFlush proto.InternalMessageInfo

type ResponseFlush struct {
}

func (m *ResponseFlush) Reset()         { *m = ResponseFlush{} }
func (m *ResponseFlush) String() string { return proto.CompactTextString(m) }
func (*ResponseFlush) ProtoMessage()    {}
func (*ResponseFlush) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{15}
}
func (m *ResponseFlush) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseFlush) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseFlush.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseFlush) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseFlush.Merge(m, src)
}
func (m *ResponseFlush) XXX_Size() int {
	return m.Size()
}
func (m *ResponseFlush) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseFlush.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseFlush proto.InternalMessageInfo

type RequestEcho struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RequestEcho) Reset()         { *m = RequestEcho{} }
func (m *RequestEcho) String() string { return proto.CompactTextString(m) }
func (*RequestEcho) ProtoMessage()    {}
func (*RequestEcho) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{16}
}
func (m *RequestEcho) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestEcho) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestEcho.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestEcho) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestEcho.Merge(m, src)
}
func (m *RequestEcho) XXX_Size() int {
	return m.Size()
}
func (m *RequestEcho) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestEcho.DiscardUnknown(m)
}

var xxx_messageInfo_RequestEcho proto.InternalMessageInfo

func (m *RequestEcho) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type RequestInfo struct {
	Version      string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	BlockVersion uint64 `protobuf:"varint,2,opt,name=block_version,json=blockVersion,proto3" json:"block_version,omitempty"`
	P2PVersion   uint64 `protobuf:"varint,3,opt,name=p2p_version,json=p2pVersion,proto3" json:"p2p_version,omitempty"`
	AbciVersion  string `protobuf:"bytes,4,opt,name=abci_version,json=abciVersion,proto3" json:"abci_version,omitempty"`
}

func (m *RequestInfo) Reset()         { *m = RequestInfo{} }
func (m *RequestInfo) String() string { return proto.CompactTextString(m) }
func (*RequestInfo) ProtoMessage()    {}
func (*RequestInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{17}
}
func (m *RequestInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestInfo.Merge(m, src)
}
func (m *RequestInfo) XXX_Size() int {
	return m.Size()
}
func (m *RequestInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RequestInfo proto.InternalMessageInfo

func (m *RequestInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *RequestInfo) GetBlockVersion() uint64 {
	if m != nil {
		return m.BlockVersion
	}
	return 0
}

func (m *RequestInfo) GetP2PVersion() uint64 {
	if m != nil {
		return m.P2PVersion
	}
	return 0
}

func (m *RequestInfo) GetAbciVersion() string {
	if m != nil {
		return m.AbciVersion
	}
	return ""
}

type RequestQuery struct {
	Data   []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Path   string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Height int64  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	Prove  bool   `protobuf:"varint,4,opt,name=prove,proto3" json:"prove,omitempty"`
}

func (m *RequestQuery) Reset()         { *m = RequestQuery{} }
func (m *RequestQuery) String() string { return proto.CompactTextString(m) }
func (*RequestQuery) ProtoMessage()    {}
func (*RequestQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{18}
}
func (m *RequestQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestQuery.Merge(m, src)
}
func (m *RequestQuery) XXX_Size() int {
	return m.Size()
}
func (m *RequestQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestQuery.DiscardUnknown(m)
}

var xxx_messageInfo_RequestQuery proto.InternalMessageInfo

func (m *RequestQuery) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *RequestQuery) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *RequestQuery) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *RequestQuery) GetProve() bool {
	if m != nil {
		return m.Prove
	}
	return false
}

type ResponseEcho struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ResponseEcho) Reset()         { *m = ResponseEcho{} }
func (m *ResponseEcho) String() string { return proto.CompactTextString(m) }
func (*ResponseEcho) ProtoMessage()    {}
func (*ResponseEcho) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{19}
}
func (m *ResponseEcho) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseEcho) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseEcho.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseEcho) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseEcho.Merge(m, src)
}
func (m *ResponseEcho) XXX_Size() int {
	return m.Size()
}
func (m *ResponseEcho) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseEcho.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseEcho proto.InternalMessageInfo

func (m *ResponseEcho) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ResponseInfo struct {
	Data             string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Version          string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	AppVersion       uint64 `protobuf:"varint,3,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	LastBlockHeight  int64  `protobuf:"varint,4,opt,name=last_block_height,json=lastBlockHeight,proto3" json:"last_block_height,omitempty"`
	LastBlockAppHash []byte `protobuf:"bytes,5,opt,name=last_block_app_hash,json=lastBlockAppHash,proto3" json:"last_block_app_hash,omitempty"`
}

func (m *ResponseInfo) Reset()         { *m = ResponseInfo{} }
func (m *ResponseInfo) String() string { return proto.CompactTextString(m) }
func (*ResponseInfo) ProtoMessage()    {}
func (*ResponseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{20}
}
func (m *ResponseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseInfo.Merge(m, src)
}
func (m *ResponseInfo) XXX_Size() int {
	return m.Size()
}
func (m *ResponseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseInfo proto.InternalMessageInfo

func (m *ResponseInfo) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *ResponseInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ResponseInfo) GetAppVersion() uint64 {
	if m != nil {
		return m.AppVersion
	}
	return 0
}

func (m *ResponseInfo) GetLastBlockHeight() int64 {
	if m != nil {
		return m.LastBlockHeight
	}
	return 0
}

func (m *ResponseInfo) GetLastBlockAppHash() []byte {
	if m != nil {
		return m.LastBlockAppHash
	}
	return nil
}

type ResponseQuery struct {
	Code uint32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	// bytes data = 2; // use "value" instead.
	Log       string           `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
	Info      string           `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	Index     int64            `protobuf:"varint,5,opt,name=index,proto3" json:"index,omitempty"`
	Key       []byte           `protobuf:"bytes,6,opt,name=key,proto3" json:"key,omitempty"`
	Value     []byte           `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
	ProofOps  *crypto.ProofOps `protobuf:"bytes,8,opt,name=proof_ops,json=proofOps,proto3" json:"proof_ops,omitempty"`
	Height    int64            `protobuf:"varint,9,opt,name=height,proto3" json:"height,omitempty"`
	Codespace string           `protobuf:"bytes,10,opt,name=codespace,proto3" json:"codespace,omitempty"`
}

func (m *ResponseQuery) Reset()         { *m = ResponseQuery{} }
func (m *ResponseQuery) String() string { return proto.CompactTextString(m) }
func (*ResponseQuery) ProtoMessage()    {}
func (*ResponseQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{21}
}
func (m *ResponseQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseQuery.Merge(m, src)
}
func (m *ResponseQuery) XXX_Size() int {
	return m.Size()
}
func (m *ResponseQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseQuery.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseQuery proto.InternalMessageInfo

func (m *ResponseQuery) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ResponseQuery) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

func (m *ResponseQuery) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *ResponseQuery) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ResponseQuery) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ResponseQuery) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ResponseQuery) GetProofOps() *crypto.ProofOps {
	if m != nil {
		return m.ProofOps
	}
	return nil
}

func (m *ResponseQuery) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ResponseQuery) GetCodespace() string {
	if m != nil {
		return m.Codespace
	}
	return ""
}

// nondeterministic
type ResponseException struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ResponseException) Reset()         { *m = ResponseException{} }
func (m *ResponseException) String() string { return proto.CompactTextString(m) }
func (*ResponseException) ProtoMessage()    {}
func (*ResponseException) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd5084df8e613950, []int{22}
}
func (m *ResponseException) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseException) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseException.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseException) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseException.Merge(m, src)
}
func (m *ResponseException) XXX_Size() int {
	return m.Size()
}
func (m *ResponseException) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseException.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseException proto.InternalMessageInfo

func (m *ResponseException) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*Request)(nil), "pelldvs.avsi.Request")
	proto.RegisterType((*Response)(nil), "pelldvs.avsi.Response")
	proto.RegisterType((*DVSRequest)(nil), "pelldvs.avsi.DVSRequest")
	proto.RegisterType((*OperatorPubkeys)(nil), "pelldvs.avsi.OperatorPubkeys")
	proto.RegisterType((*Operator)(nil), "pelldvs.avsi.Operator")
	proto.RegisterType((*RequestProcessDVSRequest)(nil), "pelldvs.avsi.RequestProcessDVSRequest")
	proto.RegisterType((*RequestProcessDVSResponse)(nil), "pelldvs.avsi.RequestProcessDVSResponse")
	proto.RegisterType((*ResponseProcessDVSRequest)(nil), "pelldvs.avsi.ResponseProcessDVSRequest")
	proto.RegisterType((*ResponseProcessDVSResponse)(nil), "pelldvs.avsi.ResponseProcessDVSResponse")
	proto.RegisterType((*Event)(nil), "pelldvs.avsi.Event")
	proto.RegisterType((*EventAttribute)(nil), "pelldvs.avsi.EventAttribute")
	proto.RegisterType((*DVSResponse)(nil), "pelldvs.avsi.DVSResponse")
	proto.RegisterType((*NonSignerStakeIndice)(nil), "pelldvs.avsi.NonSignerStakeIndice")
	proto.RegisterType((*DVSRequestResult)(nil), "pelldvs.avsi.DVSRequestResult")
	proto.RegisterType((*RequestFlush)(nil), "pelldvs.avsi.RequestFlush")
	proto.RegisterType((*ResponseFlush)(nil), "pelldvs.avsi.ResponseFlush")
	proto.RegisterType((*RequestEcho)(nil), "pelldvs.avsi.RequestEcho")
	proto.RegisterType((*RequestInfo)(nil), "pelldvs.avsi.RequestInfo")
	proto.RegisterType((*RequestQuery)(nil), "pelldvs.avsi.RequestQuery")
	proto.RegisterType((*ResponseEcho)(nil), "pelldvs.avsi.ResponseEcho")
	proto.RegisterType((*ResponseInfo)(nil), "pelldvs.avsi.ResponseInfo")
	proto.RegisterType((*ResponseQuery)(nil), "pelldvs.avsi.ResponseQuery")
	proto.RegisterType((*ResponseException)(nil), "pelldvs.avsi.ResponseException")
}

func init() { proto.RegisterFile("pelldvs/avsi/types.proto", fileDescriptor_fd5084df8e613950) }

var fileDescriptor_fd5084df8e613950 = []byte{
	// 1604 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4f, 0x6f, 0xdb, 0xca,
	0x11, 0xd7, 0x5f, 0x4b, 0x1a, 0xc9, 0xff, 0xd6, 0x6a, 0x4a, 0xcb, 0x7e, 0x76, 0xca, 0x16, 0x8d,
	0xfb, 0x5e, 0x6b, 0xc7, 0x32, 0x1e, 0x8a, 0x02, 0xfd, 0x67, 0xc3, 0xae, 0x6d, 0x14, 0x75, 0xdc,
	0x75, 0x1b, 0xb4, 0x49, 0x01, 0x82, 0x12, 0xd7, 0x14, 0x21, 0x99, 0xdc, 0x70, 0x29, 0x25, 0xbe,
	0xf6, 0x13, 0x04, 0x48, 0x3f, 0x4b, 0x91, 0x8f, 0x90, 0x5b, 0x73, 0x6b, 0x81, 0x02, 0x41, 0xe1,
	0xdc, 0x7a, 0x2e, 0x7a, 0x2e, 0x76, 0x76, 0x49, 0x91, 0xb6, 0xa4, 0x38, 0xe8, 0xe9, 0xdd, 0x76,
	0x66, 0x7f, 0x33, 0x1c, 0xce, 0x0c, 0x7f, 0x3b, 0x4b, 0x30, 0x38, 0x1b, 0x0c, 0x9c, 0x91, 0xd8,
	0xb1, 0x47, 0xc2, 0xdb, 0x89, 0xae, 0x39, 0x13, 0xdb, 0x3c, 0x0c, 0xa2, 0x80, 0x34, 0xf4, 0xce,
	0xb6, 0xdc, 0x69, 0xb5, 0x62, 0x5c, 0x37, 0xbc, 0xe6, 0x51, 0xb0, 0xc3, 0xc3, 0x20, 0xb8, 0x54,
	0xc8, 0x56, 0xd3, 0x0d, 0xdc, 0x00, 0x97, 0x3b, 0x72, 0xa5, 0xb4, 0xe6, 0x9b, 0x22, 0x54, 0x28,
	0x7b, 0x31, 0x64, 0x22, 0x22, 0x6d, 0x28, 0x5f, 0x0e, 0x86, 0xa2, 0x67, 0xe4, 0x1f, 0xe6, 0xb7,
	0xea, 0xed, 0xd6, 0x76, 0xda, 0xf7, 0xb6, 0x46, 0xfd, 0x4a, 0x22, 0x4e, 0x72, 0x54, 0x41, 0xc9,
	0x0e, 0x94, 0x58, 0xb7, 0x17, 0x18, 0x05, 0x34, 0x59, 0x9d, 0x68, 0x72, 0xd4, 0xed, 0x05, 0x27,
	0x39, 0x8a, 0x40, 0x69, 0xe0, 0xf9, 0x97, 0x81, 0x51, 0x9c, 0x61, 0x70, 0xea, 0x5f, 0xa2, 0x81,
	0x04, 0xca, 0xa8, 0x5e, 0x0c, 0x59, 0x78, 0x6d, 0x94, 0x66, 0x44, 0xf5, 0x5b, 0x89, 0x90, 0x51,
	0x21, 0x94, 0xfc, 0x01, 0x56, 0x78, 0x18, 0x74, 0x99, 0x10, 0x96, 0x33, 0x12, 0x56, 0xa8, 0x40,
	0x46, 0x19, 0x3d, 0x7c, 0x7f, 0xa2, 0x87, 0x73, 0x85, 0x3f, 0x7c, 0x7a, 0xa1, 0x15, 0x27, 0x39,
	0xba, 0xac, 0x9d, 0x1c, 0x8e, 0x44, 0x9c, 0xa3, 0xe7, 0xd0, 0xcc, 0x7a, 0x16, 0x3c, 0xf0, 0x05,
	0x33, 0xe6, 0xd0, 0xf5, 0xa3, 0x4f, 0xba, 0x56, 0xf0, 0x93, 0x1c, 0x25, 0x69, 0xdf, 0x4a, 0x7b,
	0x50, 0x81, 0xf2, 0xc8, 0x1e, 0x0c, 0x99, 0xf9, 0xcf, 0x22, 0x54, 0x63, 0x2d, 0xf9, 0x05, 0xd4,
	0xd8, 0xab, 0x2e, 0xe3, 0x91, 0x17, 0xf8, 0xba, 0x34, 0x9b, 0xb7, 0x9f, 0xa3, 0xa0, 0x47, 0x31,
	0xec, 0x24, 0x47, 0xc7, 0x36, 0x64, 0x2f, 0xae, 0xab, 0x2a, 0xd2, 0xda, 0x64, 0xe3, 0x5b, 0x85,
	0x7d, 0xac, 0x0b, 0x5b, 0x9c, 0x9c, 0x75, 0xfd, 0xc0, 0x74, 0x65, 0x1f, 0xeb, 0xca, 0x96, 0x66,
	0x59, 0x64, 0x4a, 0xbb, 0x17, 0x97, 0xb6, 0x3c, 0x2b, 0xb0, 0x5b, 0xb5, 0xfd, 0xe3, 0xe4, 0xda,
	0x4e, 0x29, 0x80, 0x72, 0x71, 0xcf, 0xe2, 0xfe, 0x69, 0x4a, 0x71, 0x2b, 0xe8, 0x7b, 0xeb, 0xd3,
	0xbe, 0xef, 0x57, 0xdd, 0xb7, 0x79, 0x80, 0x71, 0x28, 0x84, 0x40, 0xc9, 0xb1, 0x23, 0x1b, 0x4b,
	0xdb, 0xa0, 0xb8, 0x26, 0x0f, 0x60, 0xae, 0xc7, 0x3c, 0xb7, 0x17, 0x61, 0xcd, 0x8a, 0x54, 0x4b,
	0x64, 0x15, 0xaa, 0xdd, 0x9e, 0xed, 0xf9, 0x96, 0xe7, 0x60, 0x65, 0x8a, 0xb4, 0x82, 0xf2, 0xa9,
	0x43, 0xbe, 0x0b, 0xf3, 0x6e, 0x18, 0x0c, 0xb9, 0xe5, 0x0f, 0xaf, 0x3a, 0x2c, 0x14, 0x46, 0xe9,
	0x61, 0x71, 0x6b, 0x9e, 0x36, 0x50, 0x79, 0xa6, 0x74, 0xe4, 0xe7, 0xb0, 0xa6, 0x40, 0x51, 0x2f,
	0x64, 0xa2, 0x17, 0x0c, 0x1c, 0x8b, 0xb3, 0xb0, 0xcb, 0xfc, 0xc8, 0x76, 0x99, 0x30, 0xca, 0x68,
	0xb2, 0x8a, 0x90, 0xdf, 0xc5, 0x88, 0xf3, 0x31, 0xc0, 0xfc, 0x35, 0x2c, 0x3e, 0xe1, 0x2c, 0xb4,
	0xa3, 0x20, 0x3c, 0x1f, 0x76, 0xfa, 0xec, 0x5a, 0x90, 0x35, 0xa8, 0xb9, 0xbb, 0x16, 0x47, 0x49,
	0xbf, 0x43, 0xd5, 0xdd, 0x55, 0xbb, 0xb8, 0xd9, 0x8e, 0x37, 0x0b, 0x7a, 0xb3, 0xad, 0x36, 0xcd,
	0xbf, 0xe6, 0xa1, 0x1a, 0x7b, 0x23, 0x0b, 0x50, 0xf0, 0x1c, 0x6d, 0x5f, 0xf0, 0x1c, 0x62, 0x40,
	0xc5, 0x76, 0x9c, 0x90, 0x09, 0xa1, 0xed, 0x62, 0x51, 0xe6, 0xe0, 0x8a, 0x45, 0xb6, 0x35, 0x0c,
	0x3d, 0xcc, 0x41, 0x8d, 0x56, 0xa4, 0xfc, 0xfb, 0xd0, 0x93, 0x69, 0x13, 0x41, 0xb7, 0xcf, 0x22,
	0x6c, 0xc2, 0x1a, 0xd5, 0x12, 0x69, 0x42, 0x59, 0x44, 0x76, 0x9f, 0x61, 0xa3, 0x15, 0xa9, 0x12,
	0xc8, 0x8f, 0xa1, 0xa2, 0x22, 0x13, 0xba, 0x7b, 0xbe, 0xc8, 0x56, 0xf8, 0xd6, 0x9b, 0xd2, 0x18,
	0x6d, 0xfe, 0x39, 0x0f, 0xc6, 0x34, 0xda, 0x20, 0x6d, 0xa8, 0xc4, 0x3d, 0xa9, 0x3e, 0x56, 0x23,
	0xeb, 0x75, 0x0c, 0xa5, 0x31, 0x90, 0xb4, 0xa1, 0x1a, 0xe8, 0x87, 0x19, 0x85, 0x87, 0xc5, 0xad,
	0x7a, 0xfb, 0xc1, 0xe4, 0x50, 0x68, 0x82, 0x33, 0xff, 0x92, 0x87, 0xd5, 0xa9, 0x04, 0x43, 0x7e,
	0x02, 0xf5, 0xf4, 0xd7, 0xf1, 0xa9, 0x48, 0xc0, 0x19, 0x7f, 0x05, 0x3f, 0x85, 0x46, 0xa6, 0xfb,
	0x27, 0x52, 0x7b, 0xea, 0x59, 0xb4, 0xee, 0x8c, 0xbb, 0xdc, 0x7c, 0x53, 0x90, 0x61, 0x4d, 0xf9,
	0xec, 0x64, 0xaf, 0x77, 0x03, 0x87, 0x61, 0x3c, 0xf3, 0x14, 0xd7, 0x49, 0xff, 0x17, 0x52, 0xfd,
	0xbf, 0x04, 0xc5, 0x41, 0xe0, 0xea, 0xf2, 0xca, 0xa5, 0x44, 0x25, 0xec, 0x52, 0xd3, 0xfc, 0x71,
	0x04, 0x73, 0x6c, 0xc4, 0xfc, 0x48, 0x35, 0x6e, 0xbd, 0xbd, 0x92, 0x8d, 0xf1, 0x48, 0xee, 0x1d,
	0x18, 0xef, 0x3e, 0x6c, 0xe6, 0xfe, 0xfd, 0x61, 0x73, 0x49, 0x41, 0x7f, 0x18, 0x5c, 0x79, 0x11,
	0xbb, 0xe2, 0xd1, 0x35, 0xd5, 0xc6, 0x64, 0x1d, 0x6a, 0x32, 0x10, 0xc1, 0xed, 0xae, 0x22, 0xf2,
	0x1a, 0x1d, 0x2b, 0x48, 0x0b, 0xaa, 0x19, 0x22, 0x68, 0xd0, 0x44, 0x26, 0x8f, 0x60, 0x31, 0x5e,
	0x5b, 0x8e, 0xe7, 0xca, 0x4c, 0x57, 0x11, 0xb2, 0x10, 0xab, 0x0f, 0x51, 0x6b, 0xfe, 0x2d, 0x0f,
	0xad, 0xe9, 0x84, 0xf1, 0x0d, 0x4c, 0x8b, 0xf9, 0x12, 0xca, 0xe8, 0x48, 0x46, 0x20, 0x07, 0x12,
	0x8c, 0xbd, 0x46, 0x71, 0x4d, 0x9e, 0x01, 0xd8, 0x51, 0x14, 0x7a, 0x9d, 0x61, 0xc4, 0x84, 0xee,
	0xe8, 0xf5, 0x09, 0x51, 0xec, 0xc7, 0xa0, 0x83, 0x75, 0x1d, 0x4e, 0x73, 0x6c, 0x97, 0x0a, 0x29,
	0xe5, 0xcd, 0x3c, 0x83, 0x85, 0xac, 0xad, 0xcc, 0x4a, 0xcc, 0x3d, 0x35, 0x2a, 0x97, 0xf2, 0x7b,
	0x47, 0xaa, 0xc5, 0xe4, 0xd5, 0xa8, 0x12, 0xa4, 0xd6, 0xf3, 0x1d, 0xf6, 0x0a, 0xf3, 0x57, 0xa5,
	0x4a, 0x30, 0xff, 0x5b, 0x84, 0xfa, 0xad, 0x5a, 0xdc, 0xa1, 0xe3, 0x26, 0x94, 0x59, 0x18, 0xe2,
	0xc7, 0x89, 0xfe, 0x50, 0x90, 0xc8, 0x9e, 0x2d, 0x7a, 0xe8, 0xae, 0x41, 0x71, 0x4d, 0xf6, 0xe0,
	0x81, 0x1f, 0xf8, 0x96, 0xf0, 0x5c, 0x9f, 0x85, 0x42, 0x33, 0x9f, 0xb0, 0xdc, 0x5d, 0xa4, 0xe3,
	0x06, 0x5d, 0xf1, 0x03, 0xff, 0x42, 0x6d, 0x6a, 0x5a, 0x39, 0xde, 0x25, 0x66, 0x4c, 0xdd, 0x36,
	0xef, 0x23, 0xb6, 0x8c, 0xd8, 0x3a, 0x2a, 0xf7, 0x79, 0x5f, 0x62, 0xbe, 0x07, 0x0b, 0xb1, 0x53,
	0x9b, 0xf7, 0x2d, 0xb7, 0x8d, 0x25, 0x69, 0xd0, 0x86, 0xd6, 0xee, 0xf3, 0xfe, 0x71, 0x9b, 0x7c,
	0x05, 0x24, 0x41, 0xb9, 0xae, 0x0c, 0x43, 0xba, 0x53, 0x6d, 0xbb, 0x18, 0x23, 0x5d, 0xf7, 0xc2,
	0x73, 0x8f, 0x77, 0xc9, 0x21, 0x6c, 0x8e, 0x63, 0xb5, 0x54, 0x04, 0x1d, 0x2f, 0xba, 0xb2, 0xb9,
	0xe5, 0xf9, 0x8e, 0xd7, 0x65, 0xc2, 0xa8, 0xe2, 0x81, 0xb0, 0x96, 0x04, 0x7d, 0x2c, 0x41, 0x07,
	0x88, 0x39, 0x55, 0x10, 0xf2, 0x25, 0x2c, 0x27, 0xc1, 0x27, 0x76, 0x35, 0xb4, 0x5b, 0x8c, 0x5f,
	0x20, 0xc6, 0x6e, 0xc3, 0x4a, 0x14, 0x44, 0xf6, 0xc0, 0x42, 0x02, 0x4e, 0xd0, 0x80, 0xe8, 0x65,
	0xdc, 0xba, 0x90, 0x3b, 0x31, 0xfe, 0x39, 0x18, 0xa9, 0x08, 0xb3, 0x46, 0x75, 0xec, 0x2a, 0x33,
	0xdb, 0x55, 0x67, 0x71, 0xa0, 0x29, 0x37, 0xf4, 0x5b, 0xfe, 0x04, 0xad, 0x30, 0x7f, 0x03, 0xcd,
	0x49, 0x70, 0xf2, 0x35, 0x7c, 0x7b, 0xca, 0x43, 0x8d, 0x3c, 0x06, 0xda, 0x9c, 0xe4, 0xcf, 0xbc,
	0x29, 0xc0, 0x52, 0x8a, 0x51, 0x99, 0x18, 0x0e, 0xa2, 0xff, 0x87, 0x86, 0x7b, 0xb0, 0x9e, 0x70,
	0xcb, 0xa4, 0x81, 0xa7, 0xf0, 0x59, 0x03, 0x0f, 0x5d, 0x0d, 0x6f, 0x6d, 0x4d, 0x27, 0xfc, 0xe2,
	0xe7, 0x10, 0x3e, 0xe9, 0xc3, 0x17, 0x53, 0xe2, 0xd4, 0xee, 0x4a, 0x9f, 0x37, 0x3d, 0xd1, 0xd6,
	0xa4, 0x48, 0xf5, 0xe9, 0xb2, 0x00, 0x8d, 0xf4, 0x3d, 0xc4, 0x5c, 0x84, 0xf9, 0xcc, 0xfc, 0x6a,
	0x3e, 0x82, 0x7a, 0xea, 0xd6, 0x21, 0xa7, 0x88, 0x2b, 0x26, 0x84, 0xed, 0xc6, 0xfc, 0x14, 0x8b,
	0xe6, 0xeb, 0x7c, 0x82, 0x94, 0x33, 0xa9, 0x44, 0x8e, 0x58, 0x28, 0xe2, 0x19, 0xbb, 0x46, 0x63,
	0x51, 0x0e, 0x56, 0x9d, 0x41, 0xd0, 0xed, 0x5b, 0xf1, 0xbe, 0xcc, 0x7c, 0x89, 0x36, 0x50, 0xf9,
	0x54, 0x83, 0x36, 0xa1, 0xce, 0xdb, 0x3c, 0x81, 0x14, 0x11, 0x02, 0xbc, 0xcd, 0x63, 0xc0, 0x77,
	0xa0, 0x61, 0x77, 0xba, 0x5e, 0x82, 0x50, 0x84, 0x5d, 0x97, 0x3a, 0x0d, 0x31, 0x9d, 0xe4, 0xe5,
	0x70, 0xe4, 0x9d, 0xc8, 0x44, 0x04, 0x4a, 0xdc, 0x8e, 0x7a, 0x9a, 0x88, 0x70, 0x9d, 0x1a, 0x16,
	0x8b, 0x99, 0x61, 0xb1, 0x09, 0x65, 0x1e, 0x06, 0x23, 0x55, 0x81, 0x2a, 0x55, 0x82, 0xb9, 0x25,
	0x9f, 0x32, 0x1e, 0xdf, 0x67, 0xa4, 0xe8, 0x6d, 0x7e, 0x0c, 0xc5, 0x1c, 0xa5, 0x03, 0xaa, 0xe9,
	0x80, 0x52, 0x79, 0x2b, 0x64, 0xf3, 0xb6, 0x09, 0x75, 0x9b, 0xdf, 0x49, 0x89, 0xcd, 0x93, 0x94,
	0x7c, 0x09, 0xcb, 0x03, 0x5b, 0x44, 0x96, 0xca, 0xae, 0x7e, 0x85, 0x12, 0xbe, 0xc2, 0xa2, 0xdc,
	0x38, 0x90, 0xfa, 0x13, 0xf5, 0x2e, 0x3f, 0x82, 0x95, 0x14, 0x56, 0xfa, 0x45, 0xea, 0x2d, 0x63,
	0x6a, 0x96, 0x12, 0xf4, 0x3e, 0xe7, 0x27, 0xb6, 0xe8, 0x99, 0xff, 0xc9, 0x8f, 0x1b, 0x23, 0x49,
	0xe6, 0x9d, 0x23, 0xf6, 0x7e, 0xc7, 0x69, 0x72, 0x6c, 0xe8, 0xe1, 0x11, 0x85, 0xf8, 0xd0, 0x51,
	0x24, 0x9c, 0x3d, 0x74, 0x14, 0xdd, 0xea, 0x43, 0xe7, 0x6b, 0xa8, 0xe1, 0x2d, 0xdc, 0x0a, 0xb8,
	0xc0, 0xe1, 0x20, 0xfd, 0xfd, 0xab, 0x6b, 0xfa, 0xf6, 0xb9, 0x04, 0x3c, 0xe1, 0x82, 0x56, 0xb9,
	0x5e, 0xa5, 0x6a, 0x5a, 0xcb, 0xd4, 0x34, 0x73, 0x28, 0xc3, 0xed, 0x43, 0xf9, 0x07, 0xb0, 0x7c,
	0xe7, 0x2e, 0x38, 0x3e, 0xbc, 0xf2, 0xa9, 0xc3, 0xab, 0xfd, 0xf7, 0x22, 0x94, 0xf6, 0x9f, 0x5e,
	0x9c, 0x92, 0x5f, 0x42, 0x19, 0x3f, 0x1d, 0x32, 0xe3, 0xbe, 0xdf, 0x9a, 0x75, 0x67, 0x24, 0x3f,
	0x83, 0x12, 0x76, 0xd2, 0xf4, 0xdb, 0x7f, 0x6b, 0xc6, 0xfd, 0x51, 0x9a, 0x63, 0x77, 0x4d, 0xff,
	0x17, 0xd0, 0x9a, 0x71, 0x99, 0x94, 0xf1, 0xab, 0x0a, 0xcf, 0xf8, 0x33, 0xd0, 0x9a, 0x75, 0xb5,
	0x24, 0x0e, 0x2c, 0xdf, 0x9d, 0x54, 0xef, 0xf9, 0x97, 0xa0, 0x75, 0x5f, 0x02, 0x26, 0x2e, 0x90,
	0x09, 0x93, 0xdf, 0x7d, 0xff, 0x18, 0xb4, 0xee, 0xcd, 0x9f, 0x07, 0x47, 0xef, 0x6e, 0x36, 0xf2,
	0xef, 0x6f, 0x36, 0xf2, 0xff, 0xba, 0xd9, 0xc8, 0xbf, 0xfe, 0xb8, 0x91, 0x7b, 0xff, 0x71, 0x23,
	0xf7, 0x8f, 0x8f, 0x1b, 0xb9, 0x67, 0x5f, 0xb9, 0x5e, 0xd4, 0x1b, 0x76, 0xb6, 0xbb, 0xc1, 0xd5,
	0xce, 0xe3, 0x57, 0xe7, 0x6c, 0x30, 0x38, 0x63, 0xd1, 0xcb, 0x20, 0xec, 0xef, 0xdc, 0xfd, 0xbf,
	0xd4, 0x99, 0xc3, 0x1f, 0x44, 0x7b, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xac, 0x59, 0xbf, 0x02,
	0x7c, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AVSIClient is the client API for AVSI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AVSIClient interface {
	Flush(ctx context.Context, in *RequestFlush, opts ...grpc.CallOption) (*ResponseFlush, error)
	// query
	Echo(ctx context.Context, in *RequestEcho, opts ...grpc.CallOption) (*ResponseEcho, error)
	Info(ctx context.Context, in *RequestInfo, opts ...grpc.CallOption) (*ResponseInfo, error)
	Query(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*ResponseQuery, error)
	// dvs request
	ProcessDVSRequest(ctx context.Context, in *RequestProcessDVSRequest, opts ...grpc.CallOption) (*ResponseProcessDVSRequest, error)
	ProcessDVSResponse(ctx context.Context, in *RequestProcessDVSResponse, opts ...grpc.CallOption) (*ResponseProcessDVSResponse, error)
}

type aVSIClient struct {
	cc grpc1.ClientConn
}

func NewAVSIClient(cc grpc1.ClientConn) AVSIClient {
	return &aVSIClient{cc}
}

func (c *aVSIClient) Flush(ctx context.Context, in *RequestFlush, opts ...grpc.CallOption) (*ResponseFlush, error) {
	out := new(ResponseFlush)
	err := c.cc.Invoke(ctx, "/pelldvs.avsi.AVSI/Flush", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aVSIClient) Echo(ctx context.Context, in *RequestEcho, opts ...grpc.CallOption) (*ResponseEcho, error) {
	out := new(ResponseEcho)
	err := c.cc.Invoke(ctx, "/pelldvs.avsi.AVSI/Echo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aVSIClient) Info(ctx context.Context, in *RequestInfo, opts ...grpc.CallOption) (*ResponseInfo, error) {
	out := new(ResponseInfo)
	err := c.cc.Invoke(ctx, "/pelldvs.avsi.AVSI/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aVSIClient) Query(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*ResponseQuery, error) {
	out := new(ResponseQuery)
	err := c.cc.Invoke(ctx, "/pelldvs.avsi.AVSI/Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aVSIClient) ProcessDVSRequest(ctx context.Context, in *RequestProcessDVSRequest, opts ...grpc.CallOption) (*ResponseProcessDVSRequest, error) {
	out := new(ResponseProcessDVSRequest)
	err := c.cc.Invoke(ctx, "/pelldvs.avsi.AVSI/ProcessDVSRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aVSIClient) ProcessDVSResponse(ctx context.Context, in *RequestProcessDVSResponse, opts ...grpc.CallOption) (*ResponseProcessDVSResponse, error) {
	out := new(ResponseProcessDVSResponse)
	err := c.cc.Invoke(ctx, "/pelldvs.avsi.AVSI/ProcessDVSResponse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AVSIServer is the server API for AVSI service.
type AVSIServer interface {
	Flush(context.Context, *RequestFlush) (*ResponseFlush, error)
	// query
	Echo(context.Context, *RequestEcho) (*ResponseEcho, error)
	Info(context.Context, *RequestInfo) (*ResponseInfo, error)
	Query(context.Context, *RequestQuery) (*ResponseQuery, error)
	// dvs request
	ProcessDVSRequest(context.Context, *RequestProcessDVSRequest) (*ResponseProcessDVSRequest, error)
	ProcessDVSResponse(context.Context, *RequestProcessDVSResponse) (*ResponseProcessDVSResponse, error)
}

// UnimplementedAVSIServer can be embedded to have forward compatible implementations.
type UnimplementedAVSIServer struct {
}

func (*UnimplementedAVSIServer) Flush(ctx context.Context, req *RequestFlush) (*ResponseFlush, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Flush not implemented")
}
func (*UnimplementedAVSIServer) Echo(ctx context.Context, req *RequestEcho) (*ResponseEcho, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}
func (*UnimplementedAVSIServer) Info(ctx context.Context, req *RequestInfo) (*ResponseInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (*UnimplementedAVSIServer) Query(ctx context.Context, req *RequestQuery) (*ResponseQuery, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (*UnimplementedAVSIServer) ProcessDVSRequest(ctx context.Context, req *RequestProcessDVSRequest) (*ResponseProcessDVSRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessDVSRequest not implemented")
}
func (*UnimplementedAVSIServer) ProcessDVSResponse(ctx context.Context, req *RequestProcessDVSResponse) (*ResponseProcessDVSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessDVSResponse not implemented")
}

func RegisterAVSIServer(s grpc1.Server, srv AVSIServer) {
	s.RegisterService(&_AVSI_serviceDesc, srv)
}

func _AVSI_Flush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestFlush)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AVSIServer).Flush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pelldvs.avsi.AVSI/Flush",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AVSIServer).Flush(ctx, req.(*RequestFlush))
	}
	return interceptor(ctx, in, info, handler)
}

func _AVSI_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEcho)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AVSIServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pelldvs.avsi.AVSI/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AVSIServer).Echo(ctx, req.(*RequestEcho))
	}
	return interceptor(ctx, in, info, handler)
}

func _AVSI_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AVSIServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pelldvs.avsi.AVSI/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AVSIServer).Info(ctx, req.(*RequestInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AVSI_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AVSIServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pelldvs.avsi.AVSI/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AVSIServer).Query(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _AVSI_ProcessDVSRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestProcessDVSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AVSIServer).ProcessDVSRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pelldvs.avsi.AVSI/ProcessDVSRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AVSIServer).ProcessDVSRequest(ctx, req.(*RequestProcessDVSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AVSI_ProcessDVSResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestProcessDVSResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AVSIServer).ProcessDVSResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pelldvs.avsi.AVSI/ProcessDVSResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AVSIServer).ProcessDVSResponse(ctx, req.(*RequestProcessDVSResponse))
	}
	return interceptor(ctx, in, info, handler)
}

var AVSI_serviceDesc = _AVSI_serviceDesc
var _AVSI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pelldvs.avsi.AVSI",
	HandlerType: (*AVSIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Flush",
			Handler:    _AVSI_Flush_Handler,
		},
		{
			MethodName: "Echo",
			Handler:    _AVSI_Echo_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _AVSI_Info_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _AVSI_Query_Handler,
		},
		{
			MethodName: "ProcessDVSRequest",
			Handler:    _AVSI_ProcessDVSRequest_Handler,
		},
		{
			MethodName: "ProcessDVSResponse",
			Handler:    _AVSI_ProcessDVSResponse_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pelldvs/avsi/types.proto",
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Request_Flush) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Flush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flush != nil {
		{
			size, err := m.Flush.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Request_Echo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Echo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Echo != nil {
		{
			size, err := m.Echo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Request_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Request_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Request_ProcessDvsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_ProcessDvsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProcessDvsRequest != nil {
		{
			size, err := m.ProcessDvsRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Request_ProcessDvsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_ProcessDvsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProcessDvsResponse != nil {
		{
			size, err := m.ProcessDvsResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response_Exception) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Exception) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Exception != nil {
		{
			size, err := m.Exception.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Response_Flush) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Flush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flush != nil {
		{
			size, err := m.Flush.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Response_Echo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Echo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Echo != nil {
		{
			size, err := m.Echo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Response_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Response_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Response_ProcessDvsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_ProcessDvsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProcessDvsRequest != nil {
		{
			size, err := m.ProcessDvsRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Response_ProcessDvsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_ProcessDvsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProcessDvsResponse != nil {
		{
			size, err := m.ProcessDvsResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DVSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DVSRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DVSRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupThresholdPercentages) > 0 {
		dAtA15 := make([]byte, len(m.GroupThresholdPercentages)*10)
		var j14 int
		for _, num := range m.GroupThresholdPercentages {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintTypes(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GroupNumbers) > 0 {
		dAtA17 := make([]byte, len(m.GroupNumbers)*10)
		var j16 int
		for _, num := range m.GroupNumbers {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintTypes(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x22
	}
	if m.ChainId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OperatorPubkeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorPubkeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperatorPubkeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.G2Pubkey) > 0 {
		i -= len(m.G2Pubkey)
		copy(dAtA[i:], m.G2Pubkey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.G2Pubkey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.G1Pubkey) > 0 {
		i -= len(m.G1Pubkey)
		copy(dAtA[i:], m.G1Pubkey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.G1Pubkey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Operator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pubkeys != nil {
		{
			size, err := m.Pubkeys.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Stake != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Stake))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Socket) > 0 {
		i -= len(m.Socket)
		copy(dAtA[i:], m.Socket)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Socket)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MetaUri) > 0 {
		i -= len(m.MetaUri)
		copy(dAtA[i:], m.MetaUri)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MetaUri)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestProcessDVSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestProcessDVSRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestProcessDVSRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		for iNdEx := len(m.Operator) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Operator[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestProcessDVSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestProcessDVSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestProcessDVSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DvsResponse != nil {
		{
			size, err := m.DvsResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DvsRequest != nil {
		{
			size, err := m.DvsRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseProcessDVSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseProcessDVSRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseProcessDVSRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponseDigest) > 0 {
		i -= len(m.ResponseDigest)
		copy(dAtA[i:], m.ResponseDigest)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseDigest)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Response) > 0 {
		i -= len(m.Response)
		copy(dAtA[i:], m.Response)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Response)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Codespace) > 0 {
		i -= len(m.Codespace)
		copy(dAtA[i:], m.Codespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Codespace)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Log) > 0 {
		i -= len(m.Log)
		copy(dAtA[i:], m.Log)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Log)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseProcessDVSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseProcessDVSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseProcessDVSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Codespace) > 0 {
		i -= len(m.Codespace)
		copy(dAtA[i:], m.Codespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Codespace)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Log) > 0 {
		i -= len(m.Log)
		copy(dAtA[i:], m.Log)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Log)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAttribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAttribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index {
		i--
		if m.Index {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DVSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DVSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DVSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NonSignerStakeIndices) > 0 {
		for iNdEx := len(m.NonSignerStakeIndices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NonSignerStakeIndices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.TotalStakeIndices) > 0 {
		dAtA23 := make([]byte, len(m.TotalStakeIndices)*10)
		var j22 int
		for _, num := range m.TotalStakeIndices {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintTypes(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x52
	}
	if len(m.GroupApkIndices) > 0 {
		dAtA25 := make([]byte, len(m.GroupApkIndices)*10)
		var j24 int
		for _, num := range m.GroupApkIndices {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintTypes(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.NonSignerGroupBitmapIndices) > 0 {
		dAtA27 := make([]byte, len(m.NonSignerGroupBitmapIndices)*10)
		var j26 int
		for _, num := range m.NonSignerGroupBitmapIndices {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintTypes(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SignersAggSigG1) > 0 {
		i -= len(m.SignersAggSigG1)
		copy(dAtA[i:], m.SignersAggSigG1)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SignersAggSigG1)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SignersApkG2) > 0 {
		i -= len(m.SignersApkG2)
		copy(dAtA[i:], m.SignersApkG2)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SignersApkG2)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GroupApksG1) > 0 {
		for iNdEx := len(m.GroupApksG1) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupApksG1[iNdEx])
			copy(dAtA[i:], m.GroupApksG1[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupApksG1[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NonSignersPubkeysG1) > 0 {
		for iNdEx := len(m.NonSignersPubkeysG1) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NonSignersPubkeysG1[iNdEx])
			copy(dAtA[i:], m.NonSignersPubkeysG1[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.NonSignersPubkeysG1[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NonSignerStakeIndice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NonSignerStakeIndice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NonSignerStakeIndice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NonSignerStakeIndice) > 0 {
		dAtA29 := make([]byte, len(m.NonSignerStakeIndice)*10)
		var j28 int
		for _, num := range m.NonSignerStakeIndice {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintTypes(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DVSRequestResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DVSRequestResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DVSRequestResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResponseProcessDvsResponse != nil {
		{
			size, err := m.ResponseProcessDvsResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DvsResponse != nil {
		{
			size, err := m.DvsResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ResponseProcessDvsRequest != nil {
		{
			size, err := m.ResponseProcessDvsRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DvsRequest != nil {
		{
			size, err := m.DvsRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestFlush) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestFlush) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestFlush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ResponseFlush) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseFlush) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseFlush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RequestEcho) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestEcho) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestEcho) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AbciVersion) > 0 {
		i -= len(m.AbciVersion)
		copy(dAtA[i:], m.AbciVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AbciVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.P2PVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.P2PVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockVersion))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Prove {
		i--
		if m.Prove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Height != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseEcho) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseEcho) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseEcho) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LastBlockAppHash) > 0 {
		i -= len(m.LastBlockAppHash)
		copy(dAtA[i:], m.LastBlockAppHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LastBlockAppHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LastBlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastBlockHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.AppVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AppVersion))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Codespace) > 0 {
		i -= len(m.Codespace)
		copy(dAtA[i:], m.Codespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Codespace)))
		i--
		dAtA[i] = 0x52
	}
	if m.Height != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x48
	}
	if m.ProofOps != nil {
		{
			size, err := m.ProofOps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x32
	}
	if m.Index != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Log) > 0 {
		i -= len(m.Log)
		copy(dAtA[i:], m.Log)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Log)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseException) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseException) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseException) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Request_Flush) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flush != nil {
		l = m.Flush.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_Echo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Echo != nil {
		l = m.Echo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_ProcessDvsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessDvsRequest != nil {
		l = m.ProcessDvsRequest.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_ProcessDvsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessDvsResponse != nil {
		l = m.ProcessDvsResponse.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Response_Exception) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exception != nil {
		l = m.Exception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_Flush) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flush != nil {
		l = m.Flush.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_Echo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Echo != nil {
		l = m.Echo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_ProcessDvsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessDvsRequest != nil {
		l = m.ProcessDvsRequest.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_ProcessDvsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessDvsResponse != nil {
		l = m.ProcessDvsResponse.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DVSRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTypes(uint64(m.Height))
	}
	if m.ChainId != 0 {
		n += 1 + sovTypes(uint64(m.ChainId))
	}
	if len(m.GroupNumbers) > 0 {
		l = 0
		for _, e := range m.GroupNumbers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.GroupThresholdPercentages) > 0 {
		l = 0
		for _, e := range m.GroupThresholdPercentages {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *OperatorPubkeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.G1Pubkey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.G2Pubkey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Operator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MetaUri)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Socket)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Stake != 0 {
		n += 1 + sovTypes(uint64(m.Stake))
	}
	if m.Pubkeys != nil {
		l = m.Pubkeys.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RequestProcessDVSRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Operator) > 0 {
		for _, e := range m.Operator {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *RequestProcessDVSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DvsRequest != nil {
		l = m.DvsRequest.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DvsResponse != nil {
		l = m.DvsResponse.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResponseProcessDVSRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTypes(uint64(m.Code))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Log)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Codespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Response)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResponseDigest)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResponseProcessDVSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTypes(uint64(m.Code))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Log)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Codespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *EventAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Index {
		n += 2
	}
	return n
}

func (m *DVSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NonSignersPubkeysG1) > 0 {
		for _, b := range m.NonSignersPubkeysG1 {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.GroupApksG1) > 0 {
		for _, b := range m.GroupApksG1 {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.SignersApkG2)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SignersAggSigG1)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NonSignerGroupBitmapIndices) > 0 {
		l = 0
		for _, e := range m.NonSignerGroupBitmapIndices {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.GroupApkIndices) > 0 {
		l = 0
		for _, e := range m.GroupApkIndices {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.TotalStakeIndices) > 0 {
		l = 0
		for _, e := range m.TotalStakeIndices {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.NonSignerStakeIndices) > 0 {
		for _, e := range m.NonSignerStakeIndices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NonSignerStakeIndice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NonSignerStakeIndice) > 0 {
		l = 0
		for _, e := range m.NonSignerStakeIndice {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *DVSRequestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DvsRequest != nil {
		l = m.DvsRequest.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResponseProcessDvsRequest != nil {
		l = m.ResponseProcessDvsRequest.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DvsResponse != nil {
		l = m.DvsResponse.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResponseProcessDvsResponse != nil {
		l = m.ResponseProcessDvsResponse.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RequestFlush) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ResponseFlush) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RequestEcho) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RequestInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BlockVersion != 0 {
		n += 1 + sovTypes(uint64(m.BlockVersion))
	}
	if m.P2PVersion != 0 {
		n += 1 + sovTypes(uint64(m.P2PVersion))
	}
	l = len(m.AbciVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RequestQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTypes(uint64(m.Height))
	}
	if m.Prove {
		n += 2
	}
	return n
}

func (m *ResponseEcho) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResponseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AppVersion != 0 {
		n += 1 + sovTypes(uint64(m.AppVersion))
	}
	if m.LastBlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.LastBlockHeight))
	}
	l = len(m.LastBlockAppHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResponseQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTypes(uint64(m.Code))
	}
	l = len(m.Log)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovTypes(uint64(m.Index))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ProofOps != nil {
		l = m.ProofOps.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTypes(uint64(m.Height))
	}
	l = len(m.Codespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResponseException) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestFlush{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_Flush{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Echo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestEcho{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_Echo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_Info{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestQuery{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_Query{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDvsRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestProcessDVSRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_ProcessDvsRequest{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDvsResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestProcessDVSResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_ProcessDvsResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseException{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Exception{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseFlush{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Flush{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Echo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseEcho{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Echo{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Info{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseQuery{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Query{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDvsRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseProcessDVSRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_ProcessDvsRequest{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDvsResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseProcessDVSResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_ProcessDvsResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DVSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DVSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DVSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupNumbers = append(m.GroupNumbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupNumbers) == 0 {
					m.GroupNumbers = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupNumbers = append(m.GroupNumbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupNumbers", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupThresholdPercentages = append(m.GroupThresholdPercentages, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupThresholdPercentages) == 0 {
					m.GroupThresholdPercentages = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupThresholdPercentages = append(m.GroupThresholdPercentages, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupThresholdPercentages", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorPubkeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorPubkeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorPubkeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G1Pubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.G1Pubkey = append(m.G1Pubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.G1Pubkey == nil {
				m.G1Pubkey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G2Pubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.G2Pubkey = append(m.G2Pubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.G2Pubkey == nil {
				m.G2Pubkey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Socket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Socket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			m.Stake = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stake |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pubkeys == nil {
				m.Pubkeys = &OperatorPubkeys{}
			}
			if err := m.Pubkeys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestProcessDVSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestProcessDVSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestProcessDVSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &DVSRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = append(m.Operator, &Operator{})
			if err := m.Operator[len(m.Operator)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestProcessDVSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestProcessDVSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestProcessDVSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DvsRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DvsRequest == nil {
				m.DvsRequest = &DVSRequest{}
			}
			if err := m.DvsRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DvsResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DvsResponse == nil {
				m.DvsResponse = &DVSResponse{}
			}
			if err := m.DvsResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseProcessDVSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseProcessDVSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseProcessDVSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response[:0], dAtA[iNdEx:postIndex]...)
			if m.Response == nil {
				m.Response = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseDigest = append(m.ResponseDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.ResponseDigest == nil {
				m.ResponseDigest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseProcessDVSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseProcessDVSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseProcessDVSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, EventAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DVSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DVSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DVSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonSignersPubkeysG1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonSignersPubkeysG1 = append(m.NonSignersPubkeysG1, make([]byte, postIndex-iNdEx))
			copy(m.NonSignersPubkeysG1[len(m.NonSignersPubkeysG1)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupApksG1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupApksG1 = append(m.GroupApksG1, make([]byte, postIndex-iNdEx))
			copy(m.GroupApksG1[len(m.GroupApksG1)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignersApkG2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignersApkG2 = append(m.SignersApkG2[:0], dAtA[iNdEx:postIndex]...)
			if m.SignersApkG2 == nil {
				m.SignersApkG2 = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignersAggSigG1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignersAggSigG1 = append(m.SignersAggSigG1[:0], dAtA[iNdEx:postIndex]...)
			if m.SignersAggSigG1 == nil {
				m.SignersAggSigG1 = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NonSignerGroupBitmapIndices = append(m.NonSignerGroupBitmapIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NonSignerGroupBitmapIndices) == 0 {
					m.NonSignerGroupBitmapIndices = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NonSignerGroupBitmapIndices = append(m.NonSignerGroupBitmapIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NonSignerGroupBitmapIndices", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupApkIndices = append(m.GroupApkIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupApkIndices) == 0 {
					m.GroupApkIndices = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupApkIndices = append(m.GroupApkIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupApkIndices", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TotalStakeIndices = append(m.TotalStakeIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TotalStakeIndices) == 0 {
					m.TotalStakeIndices = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TotalStakeIndices = append(m.TotalStakeIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStakeIndices", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonSignerStakeIndices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonSignerStakeIndices = append(m.NonSignerStakeIndices, &NonSignerStakeIndice{})
			if err := m.NonSignerStakeIndices[len(m.NonSignerStakeIndices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NonSignerStakeIndice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NonSignerStakeIndice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NonSignerStakeIndice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NonSignerStakeIndice = append(m.NonSignerStakeIndice, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NonSignerStakeIndice) == 0 {
					m.NonSignerStakeIndice = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NonSignerStakeIndice = append(m.NonSignerStakeIndice, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NonSignerStakeIndice", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DVSRequestResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DVSRequestResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DVSRequestResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DvsRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DvsRequest == nil {
				m.DvsRequest = &DVSRequest{}
			}
			if err := m.DvsRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseProcessDvsRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseProcessDvsRequest == nil {
				m.ResponseProcessDvsRequest = &ResponseProcessDVSRequest{}
			}
			if err := m.ResponseProcessDvsRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DvsResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DvsResponse == nil {
				m.DvsResponse = &DVSResponse{}
			}
			if err := m.DvsResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseProcessDvsResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseProcessDvsResponse == nil {
				m.ResponseProcessDvsResponse = &ResponseProcessDVSResponse{}
			}
			if err := m.ResponseProcessDvsResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestFlush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestFlush: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestFlush: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseFlush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseFlush: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseFlush: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestEcho) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestEcho: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestEcho: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockVersion", wireType)
			}
			m.BlockVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P2PVersion", wireType)
			}
			m.P2PVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P2PVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbciVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbciVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Prove = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseEcho) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseEcho: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseEcho: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			m.AppVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockHeight", wireType)
			}
			m.LastBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockAppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastBlockAppHash = append(m.LastBlockAppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.LastBlockAppHash == nil {
				m.LastBlockAppHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofOps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofOps == nil {
				m.ProofOps = &crypto.ProofOps{}
			}
			if err := m.ProofOps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseException) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseException: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseException: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
